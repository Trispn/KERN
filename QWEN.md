## Qwen Added Memories
- KERN (Knowledge Execution & Reasoning Notation) is a deterministic intelligence execution language designed to encode business logic, rules, and workflows compactly. It's a logic-centric, graph-native execution language with the following core principles: determinism (same input â†’ same output, no randomness, no hidden state), minimalism (fewer primitives > expressive syntax), explicit logic (no implicit behavior), and PSI-first design (optimized for machine reasoning, not human comfort).
- KERN language primitives include: sym (symbolic identifier), num (integer), bool (true/false), vec (small fixed-size vector), ref (external reference), ctx (execution context). Structural constructs are: entity (data model), rule (inference logic), flow (execution pipeline), constraint (validation logic). The execution model is graph-based with nodes (operations, rules, conditions) and edges (data flow, control flow), with no call stack.
- KERN formal grammar (EBNF) includes entities with fields, rules with if/then structure, flows as execution pipelines, and constraints as validation logic. The grammar defines lexical elements (identifiers, numbers), program structure, entity definitions, rule definitions with conditions and actions, expressions, predicates, and control actions. The grammar is designed for deterministic parsing with no ambiguity.
- KERN bytecode uses fixed-width 8-byte instructions with format: OPCODE (1B) | ARG1 (2B) | ARG2 (2B) | ARG3 (2B) | FLAGS (1B). Core runtime registers include R0-R15 (general symbolic), CTX (execution context), ERR (error register), PC (program counter), FLAG (condition flags). Instruction categories include control flow (NOP, JMP, JMP_IF, HALT), data/symbol operations (LOAD_SYM, LOAD_NUM, MOVE, COMPARE), graph operations, rule execution, context/state, error handling, external interface, and termination.
- KERN execution graph data structures include ExecutionGraph (containing nodes, edges, entry points, registers, contexts), GraphNode (with type, opcode, flags, input/output registers, edges), GraphEdge (with from/to nodes and edge type), and specialized nodes for control flow (IF, LOOP), rules, and graph operations. The graph is a DAG at rest with explicit nodes and edges for deterministic execution.
- KERN development plan has 4 phases: Phase 1 (Foundation) - Grammar, AST, Static Validation; Phase 2 (Rule Engine) - Graph builder, Rule engine; Phase 3 (VM) - Bytecode, Virtual Machine; Phase 4 (Tooling) - Development tools, Debugger. Each phase has specific deliverables and timelines.
- When the user types '--kern', I should use all the KERN language knowledge I've stored, including the core principles, language primitives, structural constructs, formal grammar, bytecode, execution graph structures, and development plan to assist with any KERN-related requests.
- KERN (Knowledge Execution & Reasoning Notation) project structure: Multi-crate Rust workspace with 8 main components: kern-lexer (tokenization), kern-parser (AST generation), kern-ast (syntax tree definitions), kern-semantic (validation), kern-graph-builder (execution graphs), kern-rule-engine (rule execution), kern-bytecode (bytecode operations - not yet implemented), kern-vm (virtual machine - not yet implemented). The project is in Phase 2 of 4, with Phase 1 (Foundation) complete, Phase 2 (Rule Engine) in progress, and Phases 3-4 (VM/Bytecode and Tooling) not yet started. The implementation follows a formal specification with fixed-width 8-byte instructions, register-based execution (R0-R15, CTX, ERR, PC, FLAG), and explicit graph-based execution model.
