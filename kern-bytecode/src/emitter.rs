//! Bytecode Emitter
//!
//! This module converts LIR instructions to KERN bytecode instructions.

use crate::lir::{LirInstruction, LirOp, Register};
use crate::register_allocator::{PhysicalRegister, RegisterAllocation};
use crate::{Instruction, Opcode};

/// Bytecode emitter that converts LIR to bytecode
pub struct BytecodeEmitter {
    /// The generated bytecode instructions
    pub instructions: Vec<Instruction>,
    /// Current instruction pointer
    pub current_pc: u32,
    /// Jump targets that need to be patched
    pub pending_jumps: Vec<(usize, u32)>, // (instruction_index, label)
    /// Label to instruction index mapping
    pub label_map: std::collections::HashMap<u32, u32>,
}

impl BytecodeEmitter {
    pub fn new() -> Self {
        BytecodeEmitter {
            instructions: Vec::new(),
            current_pc: 0,
            pending_jumps: Vec::new(),
            label_map: std::collections::HashMap::new(),
        }
    }

    /// Emit bytecode from LIR instructions with register allocation
    pub fn emit_from_lir(&mut self, lir_instructions: &[LirInstruction], allocation: &RegisterAllocation) -> Vec<Instruction> {
        // First pass: emit instructions and record label positions
        for (idx, lir_instr) in lir_instructions.iter().enumerate() {
            match &lir_instr.op {
                LirOp::Label(label) => {
                    // Record the position of this label
                    self.label_map.insert(*label, self.current_pc);
                }
                _ => {
                    // Emit the actual instruction(s)
                    let bytecode_instrs = self.lir_to_bytecode(lir_instr, allocation);
                    for instr in bytecode_instrs {
                        self.instructions.push(instr);
                        self.current_pc += 1;
                    }
                }
            }
        }

        // Second pass: patch jump targets
        for (instr_idx, label) in &self.pending_jumps {
            if let Some(&target_pc) = self.label_map.get(label) {
                // Update the operand of the jump instruction
                if *instr_idx < self.instructions.len() {
                    let instr = &mut self.instructions[*instr_idx];
                    // For jumps, the target is stored in arg1
                    instr.arg1 = target_pc as u16;
                }
            }
        }

        std::mem::take(&mut self.instructions)
    }

    /// Convert a single LIR instruction to bytecode
    fn lir_to_bytecode(&mut self, lir_instr: &LirInstruction, allocation: &RegisterAllocation) -> Vec<Instruction> {
        let mut instructions = Vec::new();
        match &lir_instr.op {
            // Control Flow Operations
            LirOp::Nop => instructions.push(Instruction::new(Opcode::Nop as u8, 0, 0, 0, 0)),
            
            LirOp::Jmp(label) => {
                // Record this jump for later patching
                self.pending_jumps.push((self.instructions.len(), *label));
                instructions.push(Instruction::new(Opcode::Jmp as u8, 0, 0, 0, 0)); // Placeholder target
            },
            
            LirOp::JmpIf(condition, label) => {
                let cond_reg = self.get_physical_reg(*condition, allocation);
                self.pending_jumps.push((self.instructions.len(), *label));
                instructions.push(Instruction::new(Opcode::JmpIf as u8, cond_reg as u16, 0, 0, 0)); // Placeholder target
            },
            
            LirOp::JmpIfNot(condition, label) => {
                let cond_reg = self.get_physical_reg(*condition, allocation);
                self.pending_jumps.push((self.instructions.len(), *label));
                instructions.push(Instruction::new(Opcode::JmpIf as u8, cond_reg as u16, 0, 0, 0)); // Placeholder target, with inverted logic handled by VM
            },
            
            LirOp::Halt => instructions.push(Instruction::new(Opcode::Halt as u8, 0, 0, 0, 0)),
            
            LirOp::Label(_) => {
                // Labels are handled in the first pass, return NOP for this position
                instructions.push(Instruction::new(Opcode::Nop as u8, 0, 0, 0, 0));
            },
            
            // Data & Symbol Operations
            LirOp::LoadSym(symbol) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                // For now, we'll use a simple encoding where symbol names are stored in constants
                // In a real implementation, we'd have a symbol table
                instructions.push(Instruction::new(Opcode::LoadSym as u8, dst_reg as u16, 0, 0, 0));
            },
            
            LirOp::LoadNum(value) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                // In a real implementation, we'd store the value in the constant pool
                instructions.push(Instruction::new(Opcode::LoadNum as u8, dst_reg as u16, (*value as u16), 0, 0));
            },
            
            LirOp::LoadBool(value) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let bool_val = if *value { 1 } else { 0 };
                instructions.push(Instruction::new(Opcode::LoadBool as u8, dst_reg as u16, bool_val as u16, 0, 0));
            },
            
            LirOp::Move(src, dst) => {
                let src_reg = self.get_physical_reg(*src, allocation);
                let dst_reg = self.get_physical_reg(*dst, allocation);
                instructions.push(Instruction::new(Opcode::Move as u8, src_reg as u16, dst_reg as u16, 0, 0));
            },
            
            LirOp::CmpEq(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Compare as u8, left_reg as u16, right_reg as u16, dst_reg as u16, 0x00)); // EQ flag
            },
            
            LirOp::CmpNe(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Compare as u8, left_reg as u16, right_reg as u16, dst_reg as u16, 0x01)); // NE flag
            },
            
            LirOp::CmpLt(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Compare as u8, left_reg as u16, right_reg as u16, dst_reg as u16, 0x03)); // LT flag
            },
            
            LirOp::CmpLe(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Compare as u8, left_reg as u16, right_reg as u16, dst_reg as u16, 0x05)); // LE flag
            },
            
            LirOp::CmpGt(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Compare as u8, left_reg as u16, right_reg as u16, dst_reg as u16, 0x02)); // GT flag
            },
            
            LirOp::CmpGe(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Compare as u8, left_reg as u16, right_reg as u16, dst_reg as u16, 0x04)); // GE flag
            },
            
            // Arithmetic Operations
            LirOp::Add(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Add as u8, dst_reg as u16, left_reg as u16, right_reg as u16, 0));
            },
            
            LirOp::Sub(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Sub as u8, dst_reg as u16, left_reg as u16, right_reg as u16, 0));
            },
            
            LirOp::Mul(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Mul as u8, dst_reg as u16, left_reg as u16, right_reg as u16, 0));
            },
            
            LirOp::Div(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Div as u8, dst_reg as u16, left_reg as u16, right_reg as u16, 0));
            },
            
            LirOp::Mod(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Mod as u8, dst_reg as u16, left_reg as u16, right_reg as u16, 0));
            },
            
            LirOp::Neg(value) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let value_reg = self.get_physical_reg(*value, allocation);
                // Use SUB with 0 - value to implement negation
                instructions.push(Instruction::new(Opcode::Sub as u8, dst_reg as u16, 0, value_reg as u16, 0)); // 0 - value
            },
            
            // Logical Operations
            LirOp::And(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::And as u8, dst_reg as u16, left_reg as u16, right_reg as u16, 0));
            },
            
            LirOp::Or(left, right) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Or as u8, dst_reg as u16, left_reg as u16, right_reg as u16, 0));
            },
            
            LirOp::Not(value) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                let value_reg = self.get_physical_reg(*value, allocation);
                instructions.push(Instruction::new(Opcode::Not as u8, dst_reg as u16, value_reg as u16, 0, 0));
            },
            
            // Graph Operations
            LirOp::CreateNode(name) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                // In a real implementation, we'd store the node name in the constant pool
                instructions.push(Instruction::new(Opcode::CreateNode as u8, dst_reg as u16, 0, 0, 0));
            },
            
            LirOp::Connect(left, right) => {
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Connect as u8, left_reg as u16, right_reg as u16, 0, 0));
            },
            
            LirOp::Merge(left, right) => {
                let left_reg = self.get_physical_reg(*left, allocation);
                let right_reg = self.get_physical_reg(*right, allocation);
                instructions.push(Instruction::new(Opcode::Merge as u8, left_reg as u16, right_reg as u16, 0, 0));
            },
            
            LirOp::DeleteNode(node) => {
                let node_reg = self.get_physical_reg(*node, allocation);
                instructions.push(Instruction::new(Opcode::DeleteNode as u8, node_reg as u16, 0, 0, 0));
            },
            
            // Rule Execution Operations
            LirOp::RuleEntry(label, name) => {
                // Rule entry points are handled specially
                instructions.push(Instruction::new(Opcode::Nop as u8, 0, 0, 0, 0)); // Placeholder
            },
            
            LirOp::FlowEntry(label, name) => {
                // Flow entry points are handled specially
                instructions.push(Instruction::new(Opcode::Nop as u8, 0, 0, 0, 0)); // Placeholder
            },
            
            LirOp::ConstraintEntry(label, name) => {
                // Constraint entry points are handled specially
                instructions.push(Instruction::new(Opcode::Nop as u8, 0, 0, 0, 0)); // Placeholder
            },
            
            LirOp::CallRule(name) => {
                // In a real implementation, we'd store the rule name in the constant pool
                instructions.push(Instruction::new(Opcode::CallRule as u8, 0, 0, 0, 0));
            },
            
            LirOp::ReturnRule => {
                instructions.push(Instruction::new(Opcode::ReturnRule as u8, 0, 0, 0, 0));
            },
            
            LirOp::CheckCondition(condition) => {
                let cond_reg = self.get_physical_reg(*condition, allocation);
                instructions.push(Instruction::new(Opcode::CheckCondition as u8, cond_reg as u16, 0, 0, 0));
            },
            
            LirOp::ConstraintFailure(name) => {
                // In a real implementation, we'd store the constraint name in the constant pool
                instructions.push(Instruction::new(Opcode::Throw as u8, 0, 0, 0, 0));
            },
            
            // Context & State Operations
            LirOp::PushCtx => {
                instructions.push(Instruction::new(Opcode::PushCtx as u8, 0, 0, 0, 0));
            },
            
            LirOp::PopCtx => {
                instructions.push(Instruction::new(Opcode::PopCtx as u8, 0, 0, 0, 0));
            },
            
            LirOp::SetSymbol(symbol, value) => {
                let value_reg = self.get_physical_reg(*value, allocation);
                // In a real implementation, we'd store the symbol name in the constant pool
                instructions.push(Instruction::new(Opcode::SetSymbol as u8, 0, value_reg as u16, 0, 0));
            },
            
            LirOp::GetSymbol(symbol) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                // In a real implementation, we'd store the symbol name in the constant pool
                instructions.push(Instruction::new(Opcode::GetSymbol as u8, dst_reg as u16, 0, 0, 0));
            },
            
            LirOp::CopyCtx => {
                instructions.push(Instruction::new(Opcode::CopyCtx as u8, 0, 0, 0, 0));
            },
            
            // External Interface Operations
            LirOp::Call(func_name, args) => {
                // Emit Move instructions for arguments (Reg -> R0, R1, ...)
                // We assume standard calling convention where first N args go to R0..RN-1
                for (i, arg_reg) in args.iter().enumerate() {
                    if i >= 16 { break; } // Limit to 16 args
                    let src_phys = self.get_physical_reg(*arg_reg, allocation);
                    let dst_phys = i as u8;
                    if src_phys != dst_phys {
                        instructions.push(Instruction::new(Opcode::Move as u8, src_phys as u16, dst_phys as u16, 0, 0));
                    }
                }
                
                // In a real implementation, we'd store the function name in the constant pool
                // For now, using ID 0 for all external calls as per current limitation
                instructions.push(Instruction::new(Opcode::CallExtern as u8, 0, 0, 0, 0));
            },
            
            LirOp::ReadIo(io_name) => {
                let dst_reg = self.get_physical_reg(lir_instr.dst.unwrap(), allocation);
                // In a real implementation, we'd store the IO name in the constant pool
                instructions.push(Instruction::new(Opcode::ReadIo as u8, dst_reg as u16, 0, 0, 0));
            },
            
            LirOp::WriteIo(io_name, value) => {
                let value_reg = self.get_physical_reg(*value, allocation);
                // In a real implementation, we'd store the IO name in the constant pool
                instructions.push(Instruction::new(Opcode::WriteIo as u8, value_reg as u16, 0, 0, 0));
            },
            
            // Special Operations
            LirOp::Phi(dst, values) => {
                // Phi nodes are eliminated during register allocation
                // Just return a NOP as placeholder
                instructions.push(Instruction::new(Opcode::Nop as u8, 0, 0, 0, 0));
            },
        }
        instructions
    }

    /// Get the physical register for a virtual register
    fn get_physical_reg(&self, reg: Register, allocation: &RegisterAllocation) -> u8 {
        match allocation.register_map.get(&reg) {
            Some(PhysicalRegister::Physical(phys_reg)) => *phys_reg,
            Some(PhysicalRegister::Stack(slot)) => {
                // For stack slots, we need to map to a physical register
                // In a real implementation, this would involve stack operations
                // For now, we'll just return a fixed register (this is a simplification)
                0 // Use R0 as default for stack access
            }
            None => {
                // This should not happen if register allocation was done correctly
                panic!("Register {:?} not allocated", reg);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lir_builder::LirBuilder;
    use crate::register_allocator::LinearScanAllocator;

    #[test]
    fn test_bytecode_emitter_basic() {
        let mut builder = LirBuilder::new();
        
        // Create a simple program: load 5, load 3, add them
        let reg1 = builder.load_num(5);
        let reg2 = builder.load_num(3);
        let result = builder.add(reg1, reg2);
        
        let lir_program = builder.build();
        let mut allocator = LinearScanAllocator::new();
        let allocation = allocator.allocate(&lir_program);
        
        let mut emitter = BytecodeEmitter::new();
        let bytecode = emitter.emit_from_lir(&lir_program.instructions, &allocation);
        
        // Should have generated 3 bytecode instructions
        assert_eq!(bytecode.len(), 3);
        
        // Check that the opcodes are correct
        assert_eq!(bytecode[0].opcode, Opcode::LoadNum as u8);
        assert_eq!(bytecode[1].opcode, Opcode::LoadNum as u8);
        assert_eq!(bytecode[2].opcode, Opcode::Add as u8);
    }

    #[test]
    fn test_bytecode_emitter_with_control_flow() {
        let mut builder = LirBuilder::new();
        
        // Create a simple conditional: if x > 5 then print("large") else print("small")
        let x = builder.load_num(10);
        let five = builder.load_num(5);
        let cond = builder.cmp_gt(x, five);
        
        let then_label = 1;
        let end_label = 2;
        
        builder.jmp_if_not(cond, then_label);
        builder.label(then_label);
        let large_sym = builder.load_sym("large");
        builder.load_sym("print");
        builder.call("print", vec![large_sym]);
        builder.jmp(end_label);
        builder.label(end_label);
        
        let lir_program = builder.build();
        let mut allocator = LinearScanAllocator::new();
        let allocation = allocator.allocate(&lir_program);
        
        let mut emitter = BytecodeEmitter::new();
        let bytecode = emitter.emit_from_lir(&lir_program.instructions, &allocation);
        
        // Should have generated several bytecode instructions
        assert!(bytecode.len() >= 6);
    }
}
